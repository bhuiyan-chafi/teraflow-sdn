We are doing new modifications based on the files we generated by studying OpenConfig and OpenROADM standards. An walkthrough is maintained "Walkthrough.md" and tasks "Tasks.md" are also populated for future references. 

1.  Modification of the Devices model:
        -   right now we don't have additional information
        -   in addition to name and type we need "vendor" and "model"
        -   update the model to add these: 
        -   update the sql file to add some data too
    - Use the Tasks.txt file to write and perform the tasks
    - After the implementation create a section and write the walkthrough in Walkthrough.txt

2. Modification of the Endpoint model:
    -   right now we don't have endpoint(port) based capabilities
    -   each endpoint or port of a device has frequency based capabilities
    -   port of a transponder is a transceiver which supports a range of frequency and port of a roadm is either SRG or WSS which also supports a range of frequencies
    -   the manufacturer can specify the range or we can assume based on standards if they are missing in the xml configuration file
    -   we have to add "min_frequency"(double), "max_frequency"(double) and "flex_slots"(int), "bitmap_value"(try to declare the largest integer type value in postgres because it can get messy big. But I don't think postgres has something like this. So, we can declare it as text and then operate in python scripts. So, yes you can make it a text but make sure no space is in between. But I think that is also part of python not sql.)
    -   modify the model to add these
    -   modify the sql file: to add min value use this 195937.5 and for max 191556.25 and slots 700 and for current_bitmap_value pow(2,700) which is 5260135901548373507240989882880128665550339802823173859498280903068732154297080822113666536277588451226982968856178217713019432250183803863127814770651880849955223671128444598191663757884322717271293251735781376
    - Use the Tasks.txt file to write and perform the tasks
    - After the implementation create a section and write the walkthrough in Walkthrough.txt

3. Modification of the OpticalLink model:
    -   we have to remove c_slot and l_slot part
    -   also update the sql file: 
    -   Use the Tasks.txt file to write and perform the tasks
    -   don't need walkthrough for this, leave it

4. Web Interface: Devices : http://localhost:3000/devices
    -   now we have to modify the business logic and web views
    -   check the @app.route('/devices') and devices.html to see the current view
    -   we have to add the vendor name and model here
    -   Use the Tasks.txt file to write and perform the tasks
    -   After the implementation create a section and write the walkthrough in Walkthrough.txt

5. Web Interface: Devices : @app.route('/device-details/<uuid:device_id>')
    -   since we have changed the model, we have to add the new data in our web-view
    -   right now we have name, type, otn_type, in_use 
    -   we have to add min,max frequencies
    -   the values are stored in database as GHz so we have to represent them as Hz before we display in device_details.html
    -   in addition to these we have add another column as "Action" and for each row(endpoint) add a button(frequency-view) which will take it to a new web template(create) device_endpoint_frequency_view.html
    -   so create another endpoint in app.py after device details as /device-details/<uuid:endpoint_id>
    -   in the controller function call all the details of that endpoint
    -   we will decide what to do in the next prompt
    -   Use the Tasks.txt file to write and perform the tasks
    -   After the implementation create a section and write the walkthrough in Walkthrough.txt

6. The frequency view: before deciding tasks take a quick theoretical recap. We have minimum and maximum frequency range for each band as per ITU standard. And then we decide number of slots we have based on another standard. Since we are considering flex-grid, we will choose granularity 6.25GHz. So, when we want to visualize the frequencies in a 6.25GHz grid system we have to go as per the standard. Also the devices always doesn't come with exact values according to the standard but we have to display it according to the standards. We have to do some quantization in actual implementation but for now let's assume the values in database are quantized. Let's discuss the implementation now:

    -   first we have find out which optical-band our endpoint falls into
    -   we know the min and max frequencies
    -   in OpticalBands.py file we have some enums that we will use throughout the implementation
    -   since we have min max frequency of the endpoints, now we will compare with the enum class FreqeuncyRanges to check which band it falls and choose the correct enum from the class Bands and update the html view(right now you have hard-coded this)
    -   then use the use the FrequencyMeasurementUnit class to represent the min max frequencies in THz and the bandwidth should remain in GHz.
    -   for the wavelength range we have Lambdas enum class
    -   so choose the frequency > band > lambda
    -   notice that the enum variables are same for all these classes
    -   if you choose from one you can fetch the rest just by matching the name
    -   instead of Slot Width the name should be Slot Granularity because Width is 12.5 for the flex which we are not using right now. 
    -   let's make this changes now, not more than this. Then we will come up with next phase. 
    -   remember that using the OpticalBands.py makes our code modular. We will avoid hard-codes as much as possible
    -   Use the Tasks.txt file to write and perform the tasks
    -   After the implementation create a section and write the walkthrough in Walkthrough.txt

7. Frequency capabilities and Bitmap Expansion: 

    -   and endpoint's min, max frequency can vary from the standard. But visualization must always follow the standard. 
    -   For example:
        -   the ITU anchor frequency is 193.100 THz that has been specified in ITUStandards.py > ITUStandards class > ANCHOR_FREQUENCY
        -   and the min-max frequency of C-BAND is 191556250000000, 195937500000000 which is reported in our enum too
        -   but one endpoint can have less than that: 195887500000000, 191506250000000 which makes it 8+8=16 slots less than the standard
        -   but we have to represented the slots we have in the standard
        -   but we will represent unavailable slots as 0
        -   this unavailability is not based on use but based of missing capability(this is just for your understanding)
    -   so, in the controller function first we will choose the slot granularity from the enum class before everything
    -   this granularity will be passed to web view
    -   instead if hard coded 6.25GHz use that enum value and convert it using the FrequencyMeasurementUnit enums and display there (improves modularity)
    -   now let me explain the expansion:
        -   before coming to the web view we have to perform the some pre-calculation in the controller
        -   we have to slots of the endpoint coming from the database, name it endpoint_slots
        -   we choose the band the endpoint falls under, thats our operational band. Name it as "operational_band"
        -   calculate the operational_bandwidth = operational_band(max-min) in hz, don't convert anything into GHz or THz
        -   calculate the standard_slots = operational_bandwidth/enum class SLOT_GRANULARITY
        -   now we have total number of slots for two situation: endpoint_slots, standard_slots
        -   we have the anchor frequency from the enum as ANCHOR_FREQUENCY and the granularity as SLOT_GRANULARITY
        -   now in a table we start the expansion starting from the min frequency of the standard
        -   table headers will be: frequency, availability 
        -   it will expand based on SLOT_GRANULARITY slots
        -   make the ANCHOR_FREQUENCY row a different color (green) when you reach here by looping
        -   now we have visual slots according to the standard
    -   now the question is how do we compare our endpoint frequency availability?
        -   take the minimum frequency of the endpoint and the standard 
        -   if there is a difference/gap, mark that as Device.py > Constants enum > UNAVAILABLE

        -   same goes for the max frequencies
    -   which leaves us with the usable frequency
        -   endpoint_min to endpoint_max which should be marked as Constants > AVAILABLE for the standard visualization table
        -   take the endpoint_slots because this is our bitmap expansion limit
        -   we also have the bitmap value from data base
        -   reference_bitmap = 2^endpoint_slots
        -   current_bitmap = bitmap_value from database
        -   determine which bits are 0 and which ones are 1
        -   each bitmap of the bitmap represents a ITUStandards > SLOT_GRANULARITY slot
        -   the bits with the 0s mark them as Constants > IN_USE
        -   the rest remains AVAILABLE
    -   now the question is how are we going to represent the bits as frequencies?
        -   the endpoint's min frequency is the last slot of the bitmap isn't it?
        -   and we know the granularity and the max
        -   just do the math
    -   Use the Tasks.txt file to write and perform the tasks
    -   After the implementation create a section and write the walkthrough in Walkthrough.txt

8.  In case of Multiple-Band support:
    It is very common that an endpoint supports multiple band not just one. Very common in ROADM devices where each WSS ports are band-free. So, we can have mixed values in the database as min-max frequencies. So, our system must support that as well. To do that let's follow this steps:
    
    -   we have to slots of the endpoint coming from the database, name it endpoint_slots
    -   we choose the band the endpoint falls under, thats our operational band. Name it as "operational_band"  
    -   OpticalBands.py has been updated with mixed band values
    -   we choose the band the endpoint falls under, thats our operational band. Name it as "operational_band" (can be WHOLE_BAND, SCL, CL or just O, C, E that doesn't matter for now)
    -   now we have a wide min-max as per the standard
    -   so the reference bitmap now expands through the whole min-max as per the standard
    -   rest of the calculation remains same just it becomes more wide
    -   remove the Hz representation under Frequency Capabilities, THz is enough in the html
    -   Optical Band value:
        -   now this changes if it supports multiple bands
        -   check the OpticalBands.py and Bands enum class. You can find the Band values which should be visualized here
    -   so this gives us the flexibility to grow based on the values we receive from the device
    -   out implementation supports wide to wider channels
    -   update Task.txt
    -   walkthrough has grown bigger, from now we will write task based: write new WalkThroughTask8.txt for this one

8.1 	Fixing the expansion decision:
    	-   right now I can see you are expanding by default the whole band even though the database values are within C-Band only. 
    	-   which indicates you missed my points to take a decision in which values you must expand
    	-   the min max values should be checked against the enum value
    	-   from there you will get a range which can be whole, SCL, CL or just L, C, S or whatever
    	-   by default expanding it to whole band is useless and it makes the visual representation longer
   	-   update Task.txt
    	-   update WalkThroughTask8.txt

9. 	Fixing the Optical Links:

	Now that we have removed c_slot attribute from the table, we have to review the function and html view. Let's follow these steps:
	
	-	remove the c_slot usage from the ""optical_links.html"" file 
	-	since we don't have frequency view in the links anymore we can remove "link.c_slot" and "l_slot"
	-	also, we don't need to show the bitmap visualisation here, we will plan it later. So, remove it there.
	-	let's do this for now and see the web-view. Later we will decide if we can do more. 
	-   	update Task.txt
	-	we don't need walkthrough for this task

9.1	Fixing the controller functions:
	-	I can see you fixed the web-view but you didn't check the controller function and the helpers. 
	-	Due to business logic error the web-view still doesn't work. Please have a look at app.py:118
	-	update Task.txt only
	

10.	Fixing the Topology:
	-	due the c_slot change we have the same issue in /topology endpoint
	-	we have to fix the controller, helper function and web-view
	-	update Task.txt only

11.	RSA Computation: The most important and most critical.
	
	Now that we have moved the band values from links to endpoints, we have to make some adjustments there too. Let's discuss a scenario first:

	-	When we get the dijkstra path we have several nodes which means we have endpoints as ports. Which is already there.
	-	The only thing changes from before is that how to expand the bitmap? 
	-	Can you tell me how we are doing the bitmap calculation now?
	-	Good! Let me tell you now the new plan for our RSA computation:
	-	-	The functionalities remain same, just the RSA computation changes
	-	-	When we have the dijkstra path, we check the source and destination device availability first. If they are totally free or not. If not we abort. This is already implemented. 
	-	-	If the source and destination ports are usable then we proceed next.
	-	-	The first question is how many slots we need?
	-	-	We have the bandwidth from the request and in helper.py:406 we are calculating the num_slots
	-	-	Instead of using hard coded value: FLEX_GRID = 12.5 at line 405, use the enum in ITUStandards:SLOT_GRANULARITY. The value is in Hz so make it GHz first before using. Because we are receiving our bandwidth in GHz. When we acquire slots we acquire them in a 6.25GHz granularity not 12.5 so it was wrong before. Use SLOT_GRANULARITY.
	-	-	Now that we have number of slots, we have to decide how wide shall we expand our reference bitmap. 
	-	-	Do you remember how we expanded it for the endpoints frequency view? Task 8, 8.1. Let me know if you want to recap, I will provide the prompts. 
	-	-	So, now we have to another approach.
	-	-	When we have the path we check all the min, max frequencies of each endpoints of the path.
	-	-	We take two variables _reference_min_freq and _reference_max_freq	
	-	-	We take the highest frequency of all endpoints as max and min frequency as min. So, we have the highest range now.
	-	-	Then we take these two variables to the  OpticalBands.py and Bands enum class and check which class they fit into. They can fit into multiple ones: just like we did in 8 and 8.1. 
	-	-	After selecting the band, now we have a two variables _selected_min_freq and _selected_max_freq. Now this is our _reference_bitmap generation range. 
	-	-	After generating the _reference_bitmap, now we have to generate the bitmaps for the endpoints too. Don't we? To perform the Intersection. 
	-	-	Before we had the c_slot, bitmap value of links. But now we have moved them into endpoints. 
	-	-	So, we will traverse through each endpoint: take their min, max, and flex_slots and bitmap value and we will generate the bitmap for flex_slots range
	-	-	Now this will be our hop bitmap which we will intersect and move on
	-	-	Remember that we already have parallel checking, so that functionality remains there. We have update the bitmap expansion only. So make necessary adjustments.
	-	-	First-fit and Result logic remains the same but you have make new adjustments. 
	-	Additional options for RSA computation remains same. You can check the controller functions and web view to have the idea. 
	-	Write new Task_11.txt and Walkthrough_11.txt and follow them like before
	Ask me any questions before you proceed. And be very very careful, this is the most critical part of the entire project. Don't rush take your time. 

	Q&A from the Agent:
		1.	When collecting min/max frequencies for reference range, Should I iterate through all unique endpoints in the path (src and dst of each hop)?
				Yes. And your assumption is correct and it is the key-point. 

		2.	Bitmap Alignment Edge Cases
				Yes, you have to paddings as 0s. Not just one band it can be wider. For example one ROADM endpoint may support SCL band and the Transponder's endpoint may just C band. But you have to expand the Transponder's C band into SCL band to perform the intersection. 


		3.	Parallel Link Bitmap Intersection
				First, let me explain the parallel link problem. Because this is the main topic. When you will compute each hop, you have two endpoints: src and dst. Now let's say you are expanding the source endpoint bitmap. But that device has 4 more endpoints and one slot used in any of these endpoints can not be re-used. Because from an optical point of view outputs cannot pass same frequencies from two inputs. Because they will overlap(think of the WSS of a ROADM). So, the first intersection will be among the endpoints of the same device. Let's say you have the dijkstra path. It has 3 hops and 6 endpoints(3 src and 3 dst). Each of the src endpoint device has more endpoints, maybe in use for different paths but still we cannot use them. Now that we have moved the bitmap values to endpoints instead of links, we have to check the parallelism at endpoints level. What you can do is: take one endpoint(hop_src or dst) and expand it because you have slots and bitmap_value, then select the containing device, select other endpoints of the same device, get the endpoints and expand them also. Perform the intersection and save it as hop_bitmap. Now the expansion of the bitmap I think you should expand them as per _reference_bitmap width then we can make sure the frequency range is preserved. Go through the expand_path() function and check what we have there, too. 

		-	Trace Steps Visualization
		-	-	Now that we are developing, let's keep all. After we test everything we can decide how to reduce. 

		-	Reference Bitmap Initial Value
		-	-	This is a brilliant question. Yes, I think you can start with 1s because when we will loop through the endpoints and align them, eventually the padding 0s will nullify the out of boundary regions. 


11.1	Let's fix the first bug:
	
		-	if you check the first hop bitmap: Hop 1: TP1 -> RDM1
			Hop Result:            11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000

If you see the last 4 bits are 0s only. But if we check the values of  that endpoint, its 191581250000000 - 195912500000000 which falls under C-Band but we have 4 slots before and after which are unavailable. Which means we have to expand into C-Band but we have to align as per the endpoint's range. This works perfectly in the @app.route('/endpoint-details/uuid:endpoint_id'), Spectrum Allocation Table which we fixed right now. But here it's not perfectly generated. Let's fix this first. 

	The response was wrong again:


		-	No! You got it wrong. Let me explain the flow:
		-	I have the path with endpoints which has min max frequencies
		-	I choose the smallest value and the highest value
		-	I get the highest range right? That is our reference range
		- 	I take this range to the enum and check the standard which band it falls. It can be single or multiple. But we have all possible combinations there. 
		-	We choose the correct band. Now that band's min max becomes our actual _reference_min and max
		-	Now we generate the bitmap taking all 1's that is our reference bitmap. For example: 1111111111
		-	We take the first hop: TP1:1101 to RDM1:1001
		-	The source is TP1:1101 where 1101 has min, max and slots and bitmap value. Using these values the generated bitmap is 111111. But we now have to aligned it to the standards which 			is reference bitmap. So the aligned bitmap becomes 001111111100. 
		-	The dst device has the same format with different values. Imagine the generated value is also 0011111100 
		-	Now imagine TP1 and RDM1 has 2 more links in between them. So, we have 4 more endpoints from two devices. Each of these endpoints has min, max, flex_slots and bitmap. 
		-	Now we have total 6 bitmaps from first hop
		-	Intersect them and produce 1 bitmap as  _hop_bitmap
		-	For each hop the technique is same but _hop_bitmap N get intersected with N-1 to remove the slots. This is the main intention of the intersection isn't it?
		-	Finally we have a result bitmap, which is expanded to the standards but with available slots as per the endpoints. 
		-	And now we have our required slots and we perform first fit. 
	Have you understood? Or you have any questions?

12.	Acquiring the SLOTS:
	

	-	Now that we are dealing with very large bitmaps and we are visualising them on the web page. I think we can remove the bitmap logs from the code.
	-	Put some logs for data received database values in the pre-computation phase instead. For example: min, max, slot values. Not even bitmap values in the log. 
	-	Next, we have to update the acquiring slots steps. 
	-	Now that we have the result we know if the RSA passed or failed. But we have a problem there isn't it?
	-	The result bitmap is expanded to the highest range isn't it? But our endpoints has less range. 
	-	We cannot convert the result bitmap into a integer value and update our current "bitmap_value" in the database because it only expands to flex_slots.
	-	So, we can simply take our path, links
	-	For each endpoint we take the min, max, flex_slots from the database and then generate the current bitmap 11111111
	-	We take the result bitmap 001111000000, and then shrink the result bitmap according to endpoint bitmap width 11110000 and then perform intersect endpoint_bitmap & 	_ref_shrinked_bitmap = endpoint_result_bitmap
	-	Now convert it into a number and update the current value in the database for that endpoint
	-	create a new Task_12.txt and Walkthrough_12.txt and don't update any other files. It's unnecessary. 
	If you have any questions, ask me first. 

	Question and Answer:
	
		1.	The current implementation is based on previous configuration where we had the bitmap values per link, not per endpoint. The whole algorithm changes by moving the values to endpoints. And for the slot allocation. Let me ask you question, instead(even though I gave you an example but you ignored it). First question is: I have a result bitmap which 701 digit width of 1's and 0's. When you will update each endpoint bitmap, you will get a bitmap of 693 digit with. How are you gonna do the intersection? And that 693 width bitmap with bitmap_value might have some values as 0's yes. The length is not same, and if you don't bring them into same length then the frequencies for each slot changes and this destroys everything. So, tell me how you will update each endpoint bitmap value using the result bitmap(because the result is after acquiring the required slots). Answer that first.

			==>	Agent proposes, one sided shift which is risky. 
		
		2.	No, we cannot do that because one sided shift will produce wrong frequencies. The frequency range can vary from either side of min or max. I understand you are struggling with the shrinking of result bitmap. Your catch is correct. Let's solve that. 

12.1	Shrinking of Result Bitmap:
	
	-	We have the result bitmap and we already know reference_slots which we calculated in helpers.py:232. We just have to do the reverse in this case. 
	-	The result bitmap 100% sure is wide BAND then the endpoint's band. We have calculated it in rsa_bitmap_pre_compute:band_info:576
	-	So, we know what is the range of the selected band of our result bitmap(final_bitmap in your rsa_computation), we will use it
	-	now for each endpoint we will calculate the offset like task 8. How many from start and how many from end we have to remove.
	-	We will shrink the result bitmap from both ends and now we have a new result bitmap(don't change the actual one, use new variable and update each loop using the original one) but equal width of  endpoint bitmap. 
	-	Now perform intersection which will produce a new endpoint_bitmap with acquired slot using LSB first fit (in final_bitmap)
	-	Now the value should be converted to integer and then updated in the database in bitmap_value
	-	I hope this ensures exact frequency for exact slots. Because if slots shift, we have different frequencies which is disaster. 

12.2	Fixing the device status:
	
	Are we updating all the endpoints of the devices involved in the path or the just the endpoints of the path? Because I checked the devices and saw all their endpoints are marked as IN_USE : YES.
	-	We must update the endpoints only involved in the path.
ITU-T G.694.1







