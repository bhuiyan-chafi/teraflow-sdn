We are doing new modifications based on the files we generated by studying OpenConfig and OpenROADM standards. An walkthrough is maintained "Walkthrough.md" and tasks "Tasks.md" are also populated for future references. 

1.  Modification of the Devices model:
        -   right now we don't have additional information
        -   in addition to name and type we need "vendor" and "model"
        -   update the model to add these: 
        -   update the sql file to add some data too
    - Use the Tasks.txt file to write and perform the tasks
    - After the implementation create a section and write the walkthrough in Walkthrough.txt

2. Modification of the Endpoint model:
    -   right now we don't have endpoint(port) based capabilities
    -   each endpoint or port of a device has frequency based capabilities
    -   port of a transponder is a transceiver which supports a range of frequency and port of a roadm is either SRG or WSS which also supports a range of frequencies
    -   the manufacturer can specify the range or we can assume based on standards if they are missing in the xml configuration file
    -   we have to add "min_frequency"(double), "max_frequency"(double) and "flex_slots"(int), "bitmap_value"(try to declare the largest integer type value in postgres because it can get messy big. But I don't think postgres has something like this. So, we can declare it as text and then operate in python scripts. So, yes you can make it a text but make sure no space is in between. But I think that is also part of python not sql.)
    -   modify the model to add these
    -   modify the sql file: to add min value use this 195937.5 and for max 191556.25 and slots 700 and for current_bitmap_value pow(2,700) which is 5260135901548373507240989882880128665550339802823173859498280903068732154297080822113666536277588451226982968856178217713019432250183803863127814770651880849955223671128444598191663757884322717271293251735781376
    - Use the Tasks.txt file to write and perform the tasks
    - After the implementation create a section and write the walkthrough in Walkthrough.txt

3. Modification of the OpticalLink model:
    -   we have to remove c_slot and l_slot part
    -   also update the sql file: 
    -   Use the Tasks.txt file to write and perform the tasks
    -   don't need walkthrough for this, leave it

4. Web Interface: Devices : http://localhost:3000/devices
    -   now we have to modify the business logic and web views
    -   check the @app.route('/devices') and devices.html to see the current view
    -   we have to add the vendor name and model here
    -   Use the Tasks.txt file to write and perform the tasks
    -   After the implementation create a section and write the walkthrough in Walkthrough.txt

5. Web Interface: Devices : @app.route('/device-details/<uuid:device_id>')
    -   since we have changed the model, we have to add the new data in our web-view
    -   right now we have name, type, otn_type, in_use 
    -   we have to add min,max frequencies
    -   the values are stored in database as GHz so we have to represent them as Hz before we display in device_details.html
    -   in addition to these we have add another column as "Action" and for each row(endpoint) add a button(frequency-view) which will take it to a new web template(create) device_endpoint_frequency_view.html
    -   so create another endpoint in app.py after device details as /device-details/<uuid:endpoint_id>
    -   in the controller function call all the details of that endpoint
    -   we will decide what to do in the next prompt
    -   Use the Tasks.txt file to write and perform the tasks
    -   After the implementation create a section and write the walkthrough in Walkthrough.txt

6. The frequency view: before deciding tasks take a quick theoretical recap. We have minimum and maximum frequency range for each band as per ITU standard. And then we decide number of slots we have based on another standard. Since we are considering flex-grid, we will choose granularity 6.25GHz. So, when we want to visualize the frequencies in a 6.25GHz grid system we have to go as per the standard. Also the devices always doesn't come with exact values according to the standard but we have to display it according to the standards. We have to do some quantization in actual implementation but for now let's assume the values in database are quantized. Let's discuss the implementation now:

    -   first we have find out which optical-band our endpoint falls into
    -   we know the min and max frequencies
    -   in OpticalBands.py file we have some enums that we will use throughout the implementation
    -   since we have min max frequency of the endpoints, now we will compare with the enum class FreqeuncyRanges to check which band it falls and choose the correct enum from the class Bands and update the html view(right now you have hard-coded this)
    -   then use the use the FrequencyMeasurementUnit class to represent the min max frequencies in THz and the bandwidth should remain in GHz.
    -   for the wavelength range we have Lambdas enum class
    -   so choose the frequency > band > lambda
    -   notice that the enum variables are same for all these classes
    -   if you choose from one you can fetch the rest just by matching the name
    -   instead of Slot Width the name should be Slot Granularity because Width is 12.5 for the flex which we are not using right now. 
    -   let's make this changes now, not more than this. Then we will come up with next phase. 
    -   remember that using the OpticalBands.py makes our code modular. We will avoid hard-codes as much as possible
    -   Use the Tasks.txt file to write and perform the tasks
    -   After the implementation create a section and write the walkthrough in Walkthrough.txt

7. Frequency capabilities and Bitmap Expansion: 

    -   and endpoint's min, max frequency can vary from the standard. But visualization must always follow the standard. 
    -   For example:
        -   the ITU anchor frequency is 193.100 THz that has been specified in ITUStandards.py > ITUStandards class > ANCHOR_FREQUENCY
        -   and the min-max frequency of C-BAND is 191556250000000, 195937500000000 which is reported in our enum too
        -   but one endpoint can have less than that: 195887500000000, 191506250000000 which makes it 8+8=16 slots less than the standard
        -   but we have to represented the slots we have in the standard
        -   but we will represent unavailable slots as 0
        -   this unavailability is not based on use but based of missing capability(this is just for your understanding)
    -   so, in the controller function first we will choose the slot granularity from the enum class before everything
    -   this granularity will be passed to web view
    -   instead if hard coded 6.25GHz use that enum value and convert it using the FrequencyMeasurementUnit enums and display there (improves modularity)
    -   now let me explain the expansion:
        -   before coming to the web view we have to perform the some pre-calculation in the controller
        -   we have to slots of the endpoint coming from the database, name it endpoint_slots
        -   we choose the band the endpoint falls under, thats our operational band. Name it as "operational_band"
        -   calculate the operational_bandwidth = operational_band(max-min) in hz, don't convert anything into GHz or THz
        -   calculate the standard_slots = operational_bandwidth/enum class SLOT_GRANULARITY
        -   now we have total number of slots for two situation: endpoint_slots, standard_slots
        -   we have the anchor frequency from the enum as ANCHOR_FREQUENCY and the granularity as SLOT_GRANULARITY
        -   now in a table we start the expansion starting from the min frequency of the standard
        -   table headers will be: frequency, availability 
        -   it will expand based on SLOT_GRANULARITY slots
        -   make the ANCHOR_FREQUENCY row a different color (green) when you reach here by looping
        -   now we have visual slots according to the standard
    -   now the question is how do we compare our endpoint frequency availability?
        -   take the minimum frequency of the endpoint and the standard 
        -   if there is a difference/gap, mark that as Device.py > Constants enum > UNAVAILABLE

        -   same goes for the max frequencies
    -   which leaves us with the usable frequency
        -   endpoint_min to endpoint_max which should be marked as Constants > AVAILABLE for the standard visualization table
        -   take the endpoint_slots because this is our bitmap expansion limit
        -   we also have the bitmap value from data base
        -   reference_bitmap = 2^endpoint_slots
        -   current_bitmap = bitmap_value from database
        -   determine which bits are 0 and which ones are 1
        -   each bitmap of the bitmap represents a ITUStandards > SLOT_GRANULARITY slot
        -   the bits with the 0s mark them as Constants > IN_USE
        -   the rest remains AVAILABLE
    -   now the question is how are we going to represent the bits as frequencies?
        -   the endpoint's min frequency is the last slot of the bitmap isn't it?
        -   and we know the granularity and the max
        -   just do the math
    -   Use the Tasks.txt file to write and perform the tasks
    -   After the implementation create a section and write the walkthrough in Walkthrough.txt

8.  In case of Multiple-Band support:
    It is very common that an endpoint supports multiple band not just one. Very common in ROADM devices where each WSS ports are band-free. So, we can have mixed values in the database as min-max frequencies. So, our system must support that as well. To do that let's follow this steps:
    
    -   we have to slots of the endpoint coming from the database, name it endpoint_slots
    -   we choose the band the endpoint falls under, thats our operational band. Name it as "operational_band"  
    -   OpticalBands.py has been updated with mixed band values
    -   we choose the band the endpoint falls under, thats our operational band. Name it as "operational_band" (can be WHOLE_BAND, SCL, CL or just O, C, E that doesn't matter for now)
    -   now we have a wide min-max as per the standard
    -   so the reference bitmap now expands through the whole min-max as per the standard
    -   rest of the calculation remains same just it becomes more wide
    -   remove the Hz representation under Frequency Capabilities, THz is enough in the html
    -   Optical Band value:
        -   now this changes if it supports multiple bands
        -   check the OpticalBands.py and Bands enum class. You can find the Band values which should be visualized here
    -   so this gives us the flexibility to grow based on the values we receive from the device
    -   out implementation supports wide to wider channels
    -   update Task.txt
    -   walkthrough has grown bigger, from now we will write task based: write new WalkThroughTask8.txt for this one

8.1 Fixing the expansion decision:
    -   right now I can see you are expanding by default the whole band even though the database values are within C-Band only. 
    -   which indicates you missed my points to take a decision in which values you must expand
    -   the min max values should be checked against the enum value
    -   from there you will get a range which can be whole, SCL, CL or just L, C, S or whatever
    -   by default expanding it to whole band is useless and it makes the visual representation longer
    -   update Task.txt
    -   update WalkThroughTask8.txt